
/*
Adept MobileRobots Robotics Interface for Applications (ARIA)
Copyright (C) 2004-2005 ActivMedia Robotics LLC
Copyright (C) 2006-2010 MobileRobots Inc.
Copyright (C) 2011-2015 Adept Technology

     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.

     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

If you wish to redistribute ARIA under different terms, contact 
Adept MobileRobots for information about a commercial version of ARIA at 
robots@mobilerobots.com or 
Adept MobileRobots, 10 Columbia Drive, Amherst, NH 03031; +1-603-881-7960
*/

#ifndef ARVIDEOEXTERNALSOURCE_H
#define ARVIDEOEXTERNALSOURCE_H

#include "Aria.h"
#include "ArVideoInterface.h"

template<class P1, class P2, class P3, class P4>
class ArCallbackList4 : public ArGenericCallbackList<ArFunctor4<P1, P2, P3, P4>*>
{
public:
  ArCallbackList4(const char *name = "", 
			  ArLog::LogLevel logLevel = ArLog::Verbose,
			  bool singleShot = false) : 
    ArGenericCallbackList<ArFunctor4<P1, P2, P3, P4> *>(name, logLevel, singleShot)
    {
    }
  virtual ~ArCallbackList4()
    {
    }
  void invoke(P1 p1, P2 p2, P3 p3, P4 p4)
    {
      // references to members of parent class for clarity below
      ArMutex &mutex = ArGenericCallbackList<ArFunctor4<P1, P2, P3, P4> *>::myDataMutex;
      ArLog::LogLevel &loglevel = ArGenericCallbackList<ArFunctor4<P1, P2, P3, P4> *>::myLogLevel;
      const char *name = ArGenericCallbackList<ArFunctor4<P1, P2, P3, P4> *>::myName.c_str();
	    std::multimap< int, ArFunctor4<P1, P2, P3, P4>* > &list = ArGenericCallbackList<ArFunctor4<P1, P2, P3, P4> *>::myList; 
      bool &singleshot = ArGenericCallbackList<ArFunctor4<P1, P2, P3, P4> *>::mySingleShot;
      bool &logging = ArGenericCallbackList<ArFunctor4<P1, P2, P3, P4> *>::myLogging;
      
      mutex.lock();
      
      typename std::multimap<int, ArFunctor4<P1, P2, P3, P4> *>::iterator it;
      ArFunctor4<P1, P2, P3, P4> *functor;
      
      if(logging)
        ArLog::log( loglevel,  "%s: Starting calls", name);
      
      for (it = list.begin();  it != list.end(); ++it)
      {
        functor = (*it).second;
        if (functor == NULL) 
          continue;
	
        if(logging)
        {
          if (functor->getName() != NULL && functor->getName()[0] != '\0')
            ArLog::log(loglevel, "%s: Calling functor '%s' at %d", name, functor->getName(), -(*it).first);
          else
            ArLog::log(loglevel, "%s: Calling unnamed functor at %d", name, -(*it).first);
        }
        functor->invoke(p1, p2, p3, p4);
      }
      
      if(logging)
        ArLog::log(loglevel, "%s: Ended calls", name);
      
      if (singleshot)
      {
        if(logging)
          ArLog::log(loglevel, "%s: Clearing callbacks", name);
        list.clear();
      }

      mutex.unlock();
    }
};

/** An easy way to supply image data to ArVideoServer from an external source
 * such as image frames generated by or stored in your own code, or read
 * asynchronously from some source.  You can supply a pointer to read RGB image data from, or you can copy 
 * data of an image to this class, which will then be used if any network
 * requests are received.  
 * Image data is array of RGB pixel structures with one unsigned 8-bit byte for
 * each of R, G and B components of that pixel structure (so each pixel is 24
 * bits). This corresponds to the CV_8UC3 format in OpenCV.
 * 
 * For example, If you have data already in RGB unsigned char array,
 * you can just set it:
 * @code
    // ... set up ARIA, ArNetworking and ArVideo ...

    unsigned char image[width*height*3];
    // ... initialize image data ...

    ArVideoExternalSource videoSource("OpenCV Example");
    ArVideoServer *videoServer = ArVideo::createVideoServer(&serverBase, &videoSource);
    videoSource.open();

    // You can copy updated data:
    while(true)
    {
      // ... do some image processingand update the im object ...
      videoSource.setDataCopy(image, width, height);
    }


    // Or you can just supply a pointer but be sure to lock it while modifying:
    videoSource.setDataPtr(image, width, height);
    while(true)
    {
      videoSource.lock();
      // ... do some image processing and update the im object ...
      videoSource.unlock();
      videoSource.updated();
    }
  


    videoSource.close();

    
   @endcode


 * @todo XXX does ArVideoServer make a copy? If so does it do that during
 * update()? If so we can avoid copying here, and lock during update().
 *
 */
class ArVideoExternalSource : public virtual ArVideoInterface {
protected:
  std::string myName;
  bool myOpen;
  bool myUpdated;
  int myWidth;
  int myHeight;
  ArTime myUpdateTime;
  bool myDataAllocated;
  unsigned char *myData;
  ArMutex myDataMutex;
  ArCallbackList4<unsigned char* , int, int, ArTime> myVideoDataCallbacks;
public:
  ArVideoExternalSource(const char *name) : 
    ArVideoInterface(),
    myName(name), myOpen(false), myUpdated(false), 
    myWidth(0), myHeight(0), 
    myDataAllocated(false), myData(0),
    myVideoDataCallbacks(name)
  {
  
  }
  virtual ~ArVideoExternalSource() {
    lock();
    if(myDataAllocated)
      delete[] myData;
    unlock();
  }
  /// After setting the pointer, you must use lock() and unlock() while
  /// accessing the data, and call updated() each time it is changed.
  virtual bool setVideoDataPtr(unsigned char *ptr, int width, int height) {
    if(myDataAllocated)
    {
      delete[] myData;
      myDataAllocated = false;
    }
    myData = ptr;
    myWidth = width;
    myHeight = height;
    return true;
  }
  void updated() { 
    myUpdateTime.setToNow();
    myUpdated = true; 
    myVideoDataCallbacks.invoke(myData, myWidth, myHeight, myUpdateTime);
  }
  void lock() {
    myDataMutex.lock();
  }
  void unlock() { 
    myDataMutex.unlock();
  }
  /// Copy data from @a data. You do not need to lock.
  virtual bool updateVideoDataCopy(unsigned char *data, int width, int height) {
    lock();
    if(!myDataAllocated)
    {
      myData = new unsigned char[width * height * bytesPerPixel()];
      myDataAllocated = true;
    }
    // TODO reallocate if needed
    memcpy(myData, data, width*height*bytesPerPixel());
    unlock();
    updated();
    return true;
  }  
  virtual VideoFormat videoFormat() { return VIDEO_RGB24; }
  virtual int bytesPerPixel() { return 3; }
  virtual bool updateVideo() { return true; } 
  virtual bool updateVideoNow() { return myUpdated; } // todo could wait on a condition broadcast by updated
  virtual void addDataCallback(ArVideoDataCallback *functor) {
    myVideoDataCallbacks.addCallback(functor); // todo move to default implementation in ArVideoInterface?
  }
  virtual void remDataCallback(ArVideoDataCallback *functor) {
    myVideoDataCallbacks.remCallback(functor); // todo move to default implementation in ArVideoInterface?
  }
  void open() {
    myOpen = true;
  }
  void close() {
    myOpen = false;
  }
  virtual bool isOpen() {
    return myOpen;
  }
  virtual int getWidth() {
    return myWidth;
  }
  virtual int getHeight() {
    return myHeight;
  }
  virtual unsigned char *getData() {
    return myData;
  }
  virtual const char *getConfigSectionName() {
    return myName.c_str();
  }
  virtual const char *getVideoSize() {
    return "default";
  }
  virtual int getCaptureTimeSubtrahendMsecs() {
    // todo
    return 0;
  }
  virtual bool getCaptureTime(ArTime *t) {
    if(t) { 
      *t = myUpdateTime;
      return true;
    }
    return false;
  }
  virtual std::list<std::string> getCameraParameterNames() {
    return std::list<std::string>();
  }   
  virtual unsigned int getCameraParameterValue(const std::string& param) {
    return 0;
  }
  virtual ArPriority::Priority getMaxConfigParamPriority() {
    return ArPriority::NORMAL;
  }
 };

#endif
 
